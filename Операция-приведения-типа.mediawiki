Данные разных типов представляются (хранятся) в компьютере разным способом. 

Например, числовое значение, соответствующее смыслу математической записи 1 хранится разным способом, в зависимости от того, значение ли это типа <code>int</code>, или значение <code>float</code>, или значение типа <code>double</code>. 

Операция приведения типа (или: конвертации типа, преобразования типа) позволяет по значению данных одного типа получить соответствующее значение данных другого типа. 

В некоторых случаях компилятор сам добавляет такую операцию, тогда говорят, что приведение типов происходит неявно. 

В некоторых случаях необходимо это делать явно. 

Синтаксис операции: 
: (<u>тип</u>)<u>выражение</u> 

Семантика: вычислить <u>выражение</u>, а вычисленное значение преобразовать к типу <u>тип</u>. 

При некоторых преобразованиях (например, от <code>double</code> к <code>int</code>) может происходить потеря точности данных. 

Например, у вас есть целая переменная <code>n</code>: 

  int n; 

Предположим, нам надо вычислить результат деления 1 на <code>n</code>. 

При использовании операции деления, способ деления — вариант операции деления — целочисленный или дробный — определяется типами аргументов. Если оба аргумента целочисленных типов, то деление целочисленное, если хотя бы один типа с плавающей точкой, то деление нецелочисленное. 

Итак, в выражении: <code>1/n</code> — целочисленное деление. 

В выражении: <code>1.0/n</code> — деление не целочисленное, потому что константа <code>1.0</code> — это константа типа <code>double</code>. 

В выражении: <code>(double)1/n</code> — деление не целочисленное, потому что константу <code>1</code> (которая типа <code>int</code>) мы приводим к типу <code>double</code>, приоритет у операции приведения выше, чем у бинарных операций, так что запись <code>(double)1/n</code> эквивалентна по смыслу записи <code>((double)1)/n</code> (здесь скобки вокруг <code>double</code> — это запись операции приведения типа, а вокруг <code>(double)1</code> вместе — группировочные). 

В выражении: <code>1/(double)n</code> — тоже не целочисленное деление, запись эквивалентна <code>1/((double)n)</code> 

В выражении: <code>(double)1/(double)n</code> — тоже не целочисленное (в предыдущих двух случаях, когда компилятор понимает, что делить надо не целочисленно, он в результате неявно приводит и другой аргумент операции к <code>double</code> перед тем как делить один аргумент на другой). 

А в выражении: <code>(double)(1/n)</code> деление будет целочисленное, и только то, что получилось в результате деления будет приводиться к типу <code>double</code>. 